(function webpackUniversalModuleDefinition(root, factory) {
	if(typeof exports === 'object' && typeof module === 'object')
		module.exports = factory();
	else if(typeof define === 'function' && define.amd)
		define([], factory);
	else if(typeof exports === 'object')
		exports["Selo"] = factory();
	else
		root["Selo"] = factory();
})(this, function() {
return /******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};
/******/
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/
/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId])
/******/ 			return installedModules[moduleId].exports;
/******/
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			exports: {},
/******/ 			id: moduleId,
/******/ 			loaded: false
/******/ 		};
/******/
/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/
/******/ 		// Flag the module as loaded
/******/ 		module.loaded = true;
/******/
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/
/******/
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;
/******/
/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;
/******/
/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "";
/******/
/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(0);
/******/ })
/************************************************************************/
/******/ ([
/* 0 */
/*!*****************!*\
  !*** ./selo.js ***!
  \*****************/
/***/ (function(module, exports, __webpack_require__) {

	/*
	* 28 August 2016 Abdullah Mara  @abdullah
	*/
	
	var getParents = __webpack_require__(/*! ./helpers */ 1)
	var selectionPolify = __webpack_require__(/*! ./polyfill.js */ 2)
	selectionPolify.start();
	
	;(function () {
	  function Selo(props) {
	    if (!props.els) {
	
	        var log = props.log != undefined ? props.log : true
	
	        if (log) {
	          console.log("[El parameters] is not defined, this element set as body  ")
	        }
	    }
	
	    if (!document) {
	      throw "[Platfrom] not supported"
	    }
	    if (!props.iframe) {
	       this._document = document;
	    } else {
	       this._document = props.iframe;
	    }
	    if (!props.window) {
	       this._window = window;
	    } else {
	       this._window = props.window;
	    }
	
	    this._arena      = null;
	    this.selection  = null;
	    this.els         = props.els || this._document.body;
	    this._bus        = props.bus;
	
	    this.init()
	  }
	
	  Selo.prototype.init = function () {
	    this._arena = this.els;
	    this.selection = this._window.getSelection()
	
	    this.attachEvent();
	  }
	
	  Selo.prototype.attachEvent = function () {
	       var selectionEndTimeout = null,
	          contextMenuEvent    = new CustomEvent('contextMenuEvent'),
	          endEvent            = new CustomEvent('selectionEnd'),
	          startEvent          = new CustomEvent('selectionStart',{detail:this.selection}),
	          clearEvent          = new CustomEvent('removeSelectionEditor'),
	          beforeStartEvent    = new CustomEvent('selectionBeforeStart');
	
	
	      var map =  {
	        65: false,
	        91: false,
	        37: false,
	        38: false,
	        39: false,
	        40: false,
	        16: false,
	      };
	
	       // "click",
	      var listener = [
	        "mouseup",
	        "selectionchange",
	        "keyup",
	        "contextmenu",
	        "keydown"
	      ].map(function(e) {
	        this._document.addEventListener(e.toString(), function(evt/*event*/) {
	          if (evt.type != "selectionchange" && evt.type != "mouseup") {
	            if (evt.type === "contextmenu") {
	              var tmpcontextMenuEvent = new CustomEvent('contextMenuEvent', { detail: evt  })
	              // {detail:this.selection}),
	              // TODO: Should we check the target is editable ??
	              if (this._bus !== undefined) {
	                   this._bus.$emit(contextMenuEvent.type, tmpcontextMenuEvent);
	              } else {
	                   this._document.dispatchEvent(tmpcontextMenuEvent);
	              }
	              return
	            } else if (evt.type == "click") {
	      	    } else if (evt.type == "keydown") {
	                    map[evt.keyCode] = true
	            }else{
	
	              if (map[65] && map[91] ) {
	                if (this.hasText()) {
	              		  if (this._bus !== undefined) {
	              		       this._bus.$emit(endEvent.type, endEvent);
	              		  } else {
	                    	   this._document.dispatchEvent(endEvent);
	              		  }
	                }
	              }
	              else if ((map[16] && map[37]) || (map[16] && map[38]) || (map[16] && map[39]) || (map[16] && map[40]) ) {
	                if (this.hasText()) {
	              		  if (this._bus !== undefined) {
	              		   	 this._bus.$emit(endEvent.type, endEvent);
	              		  } else {
	                       this._document.dispatchEvent(endEvent);
	              		  }
	                }
	              }else{
	                // Object.keys(map).map(function(e){
	                //   map[e] = false
	                // })
	              }
	            }
	
	          }
	
	          if (evt.type == "selectionchange") {
	            // if (this.selection.type == "Range") {
	              if (this.hasText()) {
	            		  if (this._bus !== undefined) {
	            		  	   this._bus.$emit(startEvent.type, startEvent);
	            		  } else {
	                       this._document.dispatchEvent(startEvent);
	            		  }
	              } else {
	                if (this._bus !== undefined) {
	                     this._bus.$emit(clearEvent.type, clearEvent); //only clearEventType is usefull
	                } else {
	                     this._document.dispatchEvent(clearEvent);
	                }
	              }
	            // }else{
	                // if (this.inArena()) {
	                //   document.dispatchEvent(beforeStartEvent);
	                // }
	            // }
	            clearTimeout(selectionEndTimeout);
	          }
	
	          selectionEndTimeout = setTimeout(function(){
	              if (evt.type == "mouseup" && this.hasText()) {
	            		  if (this._bus !== undefined) {
	            		  	   this._bus.$emit(endEvent.type, endEvent);
	            		  } else {
	                    	this._document.dispatchEvent(endEvent);
	            		  }
	              }
	          }.bind(this), 100);
	        }.bind(this))
	      }.bind(this))
	
	    }
	
	
	  Selo.prototype.hasText = function () {
	      if (this.inArena()) {
	        return  this.selection.toString() != ""
	      }
	      return false
	    }
	
	    Selo.prototype.inArena = function () {
	      var _arena = this._document.querySelectorAll(this._arena)
	      if (this.selection.focusNode) {
	        var parents = getParents(this.selection.focusNode.parentNode);
	        var tmp = false
	
	        Object.keys(_arena).map(function(e)  {
	          if (parents.indexOf(_arena[e]) != -1) {
	            tmp = true
	          }
	        })
	        return tmp;
	      }
	      return false
	    }
	
	    Selo.prototype.getPositionRange = function () {
	
	      var oRange = this.selection.getRangeAt(0); //get the text range
	      var oRect = oRange.getBoundingClientRect();
	
	      var bound = {};
	
	      bound["left"] =  oRect.left
	      bound["top"] =  oRect.top
	      bound["getBoundingClientRect"] = oRect;
	      return  bound
	    }
	
	    Selo.prototype.saveSelection = function ()  {
	        if (this._window.getSelection) {
	            var sel = this._window.getSelection();
	            if (sel.getRangeAt && sel.rangeCount) {
	                return sel.getRangeAt(0);
	            }
	        } else if (this._document.selection && this._document.selection.createRange) {
	            return this._document.selection.createRange();
	        }
	        return null;
	    }
	
	    Selo.prototype.restoreSelection  = function (range) {
	        if (range) {
	            if (this._window.getSelection) {
	                var sel = this._window.getSelection();
	                sel.removeAllRanges();
	                sel.addRange(range);
	            } else if (this._document.selection && range.select) {
	                range.select();
	            }
	        }
	    }
	
	
	  if (true) {
	    module.exports = Selo
	  } else if (typeof define == "function" && define.amd) {
	  define([], function () {
	    return Selo
	  })
	  } else if (window.Vue) {
	    window.Selo = Selo
	  }
	
	
	
	})()


/***/ }),
/* 1 */
/*!********************!*\
  !*** ./helpers.js ***!
  \********************/
/***/ (function(module, exports) {

	
	module.exports = function getParents(el) {
	  var a = el;
	  var parents = [];
	
	  while (a) {
	      parents.unshift(a);
	      a = a.parentNode;
	  }
	  return parents;
	}


/***/ }),
/* 2 */
/*!*********************!*\
  !*** ./polyfill.js ***!
  \*********************/
/***/ (function(module, exports, __webpack_require__) {

	// github.com/2is10/selectionchange-polyfill
	
	var selectionchange = (function (undefined) {
	
	  var MAC = /^Mac/.test(navigator.platform);
	  var MAC_MOVE_KEYS = [65, 66, 69, 70, 78, 80]; // A, B, E, F, P, N from support.apple.com/en-ie/HT201236
	  var SELECT_ALL_MODIFIER = MAC ? 'metaKey' : 'ctrlKey';
	  var RANGE_PROPS = ['startContainer', 'startOffset', 'endContainer', 'endOffset'];
	  var HAS_OWN_SELECTION = {INPUT: 1, TEXTAREA: 1};
	
	  var ranges;
	
	  return {
	    start: function (doc) {
	      var d = doc || document;
	      if (ranges || !hasNativeSupport(d) && (ranges = newWeakMap())) {
	        if (!ranges.has(d)) {
	          ranges.set(d, getSelectionRange(d));
	          on(d, 'input', onInput);
	          on(d, 'keydown', onKeyDown);
	          on(d, 'mousedown', onMouseDown);
	          on(d, 'mousemove', onMouseMove);
	          on(d, 'mouseup', onMouseUp);
	          on(d.defaultView, 'focus', onFocus);
	        }
	      }
	    },
	    stop: function (doc) {
	      var d = doc || document;
	      if (ranges && ranges.has(d)) {
	        ranges['delete'](d);
	        off(d, 'input', onInput);
	        off(d, 'keydown', onKeyDown);
	        off(d, 'mousedown', onMouseDown);
	        off(d, 'mousemove', onMouseMove);
	        off(d, 'mouseup', onMouseUp);
	        off(d.defaultView, 'focus', onFocus);
	      }
	    }
	  };
	
	  function hasNativeSupport(doc) {
	    var osc = doc.onselectionchange;
	    if (osc !== undefined) {
	      try {
	        doc.onselectionchange = 0;
	        return doc.onselectionchange === null;
	      } catch (e) {
	      } finally {
	        doc.onselectionchange = osc;
	      }
	    }
	    return false;
	  }
	
	  function newWeakMap() {
	    if (typeof WeakMap !== 'undefined') {
	      return new WeakMap();
	    } else {
	      console.error('selectionchange: WeakMap not supported');
	      return null;
	    }
	  }
	
	  function getSelectionRange(doc) {
	    var s = doc.getSelection();
	    return s.rangeCount ? s.getRangeAt(0) : null;
	  }
	
	  function on(el, eventType, handler) {
	    el.addEventListener(eventType, handler, true);
	  }
	
	  function off(el, eventType, handler) {
	    el.removeEventListener(eventType, handler, true);
	  }
	
	  function onInput(e) {
	    if (!HAS_OWN_SELECTION[e.target.tagName]) {
	      dispatchIfChanged(this, true);
	    }
	  }
	
	  function onKeyDown(e) {
	    var code = e.keyCode;
	    if (code === 65 && e[SELECT_ALL_MODIFIER] && !e.shiftKey && !e.altKey || // Ctrl-A or Cmd-A
	        code >= 35 && code <= 40 || // home, end and arrow key
	        e.ctrlKey && MAC && MAC_MOVE_KEYS.indexOf(code) >= 0) {
	      if (!HAS_OWN_SELECTION[e.target.tagName]) {
	        setTimeout(dispatchIfChanged.bind(null, this), 0);
	      }
	    }
	  }
	
	  function onMouseDown(e) {
	    if (e.button === 0) {
	      on(this, 'mousemove', onMouseMove);
	      setTimeout(dispatchIfChanged.bind(null, this), 0);
	    }
	  }
	
	  function onMouseMove(e) {  // only needed while primary button is down
	    if (e.buttons & 1) {
	      dispatchIfChanged(this);
	    } else {
	      off(this, 'mousemove', onMouseMove);
	    }
	  }
	
	  function onMouseUp(e) {
	    if (e.button === 0) {
	      setTimeout(dispatchIfChanged.bind(null, this), 0);
	    } else {
	      off(this, 'mousemove', onMouseMove);
	    }
	  }
	
	  function onFocus() {
	    setTimeout(dispatchIfChanged.bind(null, this.document), 0);
	  }
	
	  function dispatchIfChanged(doc, force) {
	    var r = getSelectionRange(doc);
	    if (force || !sameRange(r, ranges.get(doc))) {
	      ranges.set(doc, r);
	      setTimeout(doc.dispatchEvent.bind(doc, new Event('selectionchange')), 0);
	    }
	  }
	
	  function sameRange(r1, r2) {
	    return r1 === r2 || r1 && r2 && RANGE_PROPS.every(function (prop) {
	      return r1[prop] === r2[prop];
	    });
	  }
	})();
	
	if (true) {
	    // CommonJS/Node compatibility.
	    module.exports = selectionchange;
	}


/***/ })
/******/ ])
});
;
//# sourceMappingURL=selo.min.js.map